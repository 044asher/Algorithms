Big O нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени.
В Big O нотации всегда рассматривается худший вариант, то есть если у нас есть вложенный цикл
который ищет нужный элемент, в Big O сложность алгоритма будем определять как будто нужный элемент
окажется самым последним.

1. O(1) - выполнение операции происходит за конкретное время. Как пример можем взять получение
первого элемента в массиве. Считается самым эффективным.

2. O(n) - выполнение алгоритма тем дольше, чем больше количество элементов задействованных в нем.
Все еще считается приемлемым. Как пример O(n) будет иметь алгоритм поиска суммы всех элементов
массива.

3. O(n^2) - выполнение алгоритма растет в квадрате в зависимости от количества элементов. Алгоритмы
в которых используются вложенные циклы проходящие по одной и той же коллекции всегда будут O(n^2).
Считается не самым удачным решением.

4. O(log n) - выполнение алгоритма расчитывается по логарифму от количества элементов. Возьмем как
пример бинарный поиск. Мы там делим массив на две части, потом еще на две и т.д чтобы найти нужный
элемент.
Т.е. в худшем случае делаем столько операций, сколько раз можем разделить массив на две
части. Например, сколько раз мы можем разделить на две части массив из 4 элементов? 2 раза.
А массив из 8 элементов? 3 раза.
Т.е. кол-во делений/операций = log2(n) (где n кол-во элементов массива).


Задание:
Сложность выполнения операций для основных коллекций в терминах Big O:

ArrayList

Вставка элемента с указанием позиции: O(n) (т.к нужно перенести всю коллекцию вправо после позиции)
Вставка элемента без указания позиции: O(1)
Получение элемента по индексу: O(1) (достаточно обратиться к элементу по индексу)
Удаление элемента по индексу: O(n) (необходимо переместить элементы, находящиеся после удаляемого элемента, на одну позицию влево)
Удаление элемента (не по индексу): O(n) (потребуется время на поиск элемента и потом так же нужно будет перенести элементы после удаленного элемента)
Contains: O(n) (требуется пройти весь массив для поиска)


LinkedList

Вставка элемента с указанием позиции: O(1) (необходимо только изменить указатели на следующий и предыдущий элементы)
Вставка элемента без указания позиции: O(1)
Получение элемента по индексу: O(n) (необходимо пройти по всей коллекции, чтобы найти элемент)
Удаление элемента по индексу: O(n) (необходимо будет пройти коллекцию, чтобы добраться до нужного элемента и разорвать связь)
Удаление элемента (не по индексу): O(n) (необходимо пройти всю коллекцию, чтобы найти нужный элемент)
Contains: O(n)


HashSet

Вставка элемента: О(1)
Удаление элемента: О(1)
Contains: О(1)


TreeSet

Вставка элемента: О(log n) (вставка в отсортированное дерево требует логарифмическое время)
Удаление элемента: О(log n) (элемент удаляется из дерева)
Contains: О(log n) (элемент ищется в дереве)


HashMap

Вставка элемента: О(1) (элемент добавляется в хэш-таблицу)
Удаление элемента: О(1) (элемент удаляется из хэш-таблицы)
Contains: О(1) (элемент ищется в хэш-таблице)


TreeMap

Вставка элемента: О(log n) (элемент добавляется в дерево)
Удаление элемента: О(log n) (элемент удаляется из дерева)
Contains: О(log n) (элемент ищется в дереве)

